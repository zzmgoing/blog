<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钟子明&amp;博客</title>
  
  
  <link href="https://zzming.cn/atom.xml" rel="self"/>
  
  <link href="https://zzming.cn/"/>
  <updated>2022-06-12T14:56:45.910Z</updated>
  <id>https://zzming.cn/</id>
  
  <author>
    <name>钟子明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android面试系列总结篇</title>
    <link href="https://zzming.cn/post/99fd5a78.html"/>
    <id>https://zzming.cn/post/99fd5a78.html</id>
    <published>2022-06-11T07:43:13.000Z</published>
    <updated>2022-06-12T14:56:45.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>熟练掌握</p>            </div> <div class='checkbox red'><input type="checkbox" />            <p>未熟练掌握</p>            </div><p>由于各种各类的知识点及面试相关问题较多，在此仅记录总结比较重要的基础知识点和高频的面试题。</p></blockquote><h1 id="Android面试之网络篇"><a href="#Android面试之网络篇" class="headerlink" title="Android面试之网络篇"></a><a href="a3e07e13.html">Android面试之网络篇</a></h1><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>TCP和UDP</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>HTTP和HTTPS</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>HTTP1.0、1.1和2.0的区别</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>HTTPS原理和请求过程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>对称和非对称加密算法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>网络耗时优化</p>            </div><h1 id="Android面试之Java基础篇"><a href="#Android面试之Java基础篇" class="headerlink" title="Android面试之Java基础篇"></a><a href="49d5b74.html">Android面试之Java基础篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>特点和特性</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>面向对象和面向过程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>八大基本数据类型</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>四大引用类型</p>            </div><details class="folding-tag" yellow><summary> 常见面试题锦集 </summary>              <div class='content'>              <ul><li>equals方法和==的区别</li><li>String、StringBuilder和StringBuffer区别</li><li>为什么String不可变，不可变对象的好处</li><li>final、finally、finalize区别</li><li>Exception和Error有什么区别</li><li>RunTimeException和其他Exception区别</li><li>泛型和类型擦除</li></ul>              </div>            </details><h1 id="Android面试之Java进阶篇"><a href="#Android面试之Java进阶篇" class="headerlink" title="Android面试之Java进阶篇"></a><a href="2615f0a7.html">Android面试之Java进阶篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>JVM的内存分配</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>GC垃圾回收机制</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>ClassLoader加载机制</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Class类的加载过程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>线程、多线程、线程池</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>锁、死锁</p>            </div><details class="folding-tag" yellow><summary> 常见面试题锦集 </summary>              <div class='content'>              <ul><li>Class类的加载执行顺序(包含静态变量和方法)</li><li>如何停止正在运行的线程</li><li>线程池ThreadPool的构造函数</li><li>进程和线程的区别</li><li>volatile的作用，能否保证线程安全</li><li>synchronized和volatile的区别</li><li>synchronized和ReentrantLock的区别</li></ul>              </div>            </details><h1 id="Android面试之基础篇"><a href="#Android面试之基础篇" class="headerlink" title="Android面试之基础篇"></a><a href="cb6039dc.html">Android面试之基础篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>Activity</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Fragment</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Service</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>BroadcastReceiver</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>ContentProvider</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>四大组件区别和Context</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Animation</p>            </div><details class="folding-tag" yellow><summary> 常见面试题锦集 </summary>              <div class='content'>              <ul><li>APK安装流程</li><li>Activity启动流程</li><li>Serializable和Parcelable区别</li><li>Activity、Window、View关系</li><li>Activity获取View宽高的三种方式</li><li>LruCache缓存机制</li><li>SharedPreferences优缺点，如何优化</li><li>ListView、RecyclerView区别</li></ul>              </div>            </details><h1 id="Android面试之进阶篇"><a href="#Android面试之进阶篇" class="headerlink" title="Android面试之进阶篇"></a><a href="e9e8920f.html">Android面试之进阶篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>Handler机制</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Binder机制</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>进程和多线程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>View事件分发</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>View绘制流程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Gradle构建流程</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>内存泄漏</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>性能优化</p>            </div><details class="folding-tag" yellow><summary> 常见面试题锦集 </summary>              <div class='content'>              <ul><li>Handler延迟消息机制</li><li>Handler异步消息和同步屏障</li><li>Looper怎么保证在线程里唯一</li><li>进程间通信方式有哪些</li><li>内存映射(mmap)原理</li><li>Binder的最大线程数量</li></ul>              </div>            </details><h1 id="Android面试之源码篇"><a href="#Android面试之源码篇" class="headerlink" title="Android面试之源码篇"></a><a href="ad6a412c.html">Android面试之源码篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>Kotlin空安全原理</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Kotlin协程原理</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>OKHttp原理</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>Retrofit原理</p>            </div><h1 id="Android面试之数据结构篇"><a href="#Android面试之数据结构篇" class="headerlink" title="Android面试之数据结构篇"></a><a href="30ef2a74.html">Android面试之数据结构篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>线性结构</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>非线性结构</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>ArrayList数据结构</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>HashMap数据结构</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>HashSet数据结构</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>二叉树的遍历和深度</p>            </div><h1 id="Android面试之算法篇"><a href="#Android面试之算法篇" class="headerlink" title="Android面试之算法篇"></a><a href="b420aa0f.html">Android面试之算法篇</a></h1><div class='checkbox red'><input type="checkbox" />            <p>算法的特征和设计原则</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>算法的空间和时间复杂度</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>算法的分类和理解</p>            </div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;div class=&#39;checkbox green checked&#39;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;/&gt;
            &lt;p&gt;熟练掌握&lt;/p&gt;
            &lt;/div&gt; &lt;div </summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之算法篇</title>
    <link href="https://zzming.cn/post/b420aa0f.html"/>
    <id>https://zzming.cn/post/b420aa0f.html</id>
    <published>2022-06-11T07:40:10.000Z</published>
    <updated>2022-06-12T13:36:14.240Z</updated>
    
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之数据结构篇</title>
    <link href="https://zzming.cn/post/30ef2a74.html"/>
    <id>https://zzming.cn/post/30ef2a74.html</id>
    <published>2022-06-11T07:38:10.000Z</published>
    <updated>2022-06-12T13:36:14.291Z</updated>
    
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之源码篇</title>
    <link href="https://zzming.cn/post/ad6a412c.html"/>
    <id>https://zzming.cn/post/ad6a412c.html</id>
    <published>2022-06-10T07:13:39.000Z</published>
    <updated>2022-06-12T13:36:14.273Z</updated>
    
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之进阶篇</title>
    <link href="https://zzming.cn/post/e9e8920f.html"/>
    <id>https://zzming.cn/post/e9e8920f.html</id>
    <published>2022-06-09T07:13:20.000Z</published>
    <updated>2022-06-12T14:56:45.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h1><h1 id="Binder机制"><a href="#Binder机制" class="headerlink" title="Binder机制"></a>Binder机制</h1><h1 id="进程和多线程"><a href="#进程和多线程" class="headerlink" title="进程和多线程"></a>进程和多线程</h1><h1 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h1><h1 id="View绘制流程"><a href="#View绘制流程" class="headerlink" title="View绘制流程"></a>View绘制流程</h1><h1 id="Gradle构建流程"><a href="#Gradle构建流程" class="headerlink" title="Gradle构建流程"></a>Gradle构建流程</h1><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><blockquote><p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，<br>从而导致程序运行速度减慢甚至系统崩溃(OOM)等严重后果。</p></blockquote><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ol><li><a href="#包体积优化">包体积优化</a></li><li><a href="#稳定性优化">稳定性优化</a></li><li><a href="#存储优化">存储优化</a></li><li><a href="#WebView优化">WebView优化</a></li><li><a href="#启动优化">启动优化</a></li></ol><h2 id="包体积优化"><a href="#包体积优化" class="headerlink" title="包体积优化"></a>包体积优化</h2><h2 id="稳定性优化"><a href="#稳定性优化" class="headerlink" title="稳定性优化"></a>稳定性优化</h2><h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><h2 id="WebView优化"><a href="#WebView优化" class="headerlink" title="WebView优化"></a>WebView优化</h2><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><h1 id="常见面试题锦集"><a href="#常见面试题锦集" class="headerlink" title="常见面试题锦集"></a>常见面试题锦集</h1><h2 id="Handler延迟消息机制"><a href="#Handler延迟消息机制" class="headerlink" title="Handler延迟消息机制"></a>Handler延迟消息机制</h2><h2 id="Handler异步消息和同步屏障"><a href="#Handler异步消息和同步屏障" class="headerlink" title="Handler异步消息和同步屏障"></a>Handler异步消息和同步屏障</h2><h2 id="Looper怎么保证在线程里唯一"><a href="#Looper怎么保证在线程里唯一" class="headerlink" title="Looper怎么保证在线程里唯一"></a>Looper怎么保证在线程里唯一</h2><h2 id="进程间通信方式有哪些"><a href="#进程间通信方式有哪些" class="headerlink" title="进程间通信方式有哪些"></a>进程间通信方式有哪些</h2><h2 id="内存映射-mmap-原理"><a href="#内存映射-mmap-原理" class="headerlink" title="内存映射(mmap)原理"></a>内存映射(mmap)原理</h2><h2 id="Binder的最大线程数量"><a href="#Binder的最大线程数量" class="headerlink" title="Binder的最大线程数量"></a>Binder的最大线程数量</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Handler机制&quot;&gt;&lt;a href=&quot;#Handler机制&quot; class=&quot;headerlink&quot; title=&quot;Handler机制&quot;&gt;&lt;/a&gt;Handler机制&lt;/h1&gt;&lt;h1 id=&quot;Binder机制&quot;&gt;&lt;a href=&quot;#Binder机制&quot; class=&quot;</summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之基础篇</title>
    <link href="https://zzming.cn/post/cb6039dc.html"/>
    <id>https://zzming.cn/post/cb6039dc.html</id>
    <published>2022-06-08T07:13:09.000Z</published>
    <updated>2022-06-12T14:50:52.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h1 id="四大组件区别和Context"><a href="#四大组件区别和Context" class="headerlink" title="四大组件区别和Context"></a>四大组件区别和Context</h1><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><h1 id="常见面试题锦集"><a href="#常见面试题锦集" class="headerlink" title="常见面试题锦集"></a>常见面试题锦集</h1><h2 id="APK安装流程"><a href="#APK安装流程" class="headerlink" title="APK安装流程"></a>APK安装流程</h2><h2 id="Activity启动流程"><a href="#Activity启动流程" class="headerlink" title="Activity启动流程"></a>Activity启动流程</h2><h2 id="Serializable和Parcelable区别"><a href="#Serializable和Parcelable区别" class="headerlink" title="Serializable和Parcelable区别"></a>Serializable和Parcelable区别</h2><h2 id="Activity、Window、View关系"><a href="#Activity、Window、View关系" class="headerlink" title="Activity、Window、View关系"></a>Activity、Window、View关系</h2><h2 id="Activity获取View宽高的三种方式"><a href="#Activity获取View宽高的三种方式" class="headerlink" title="Activity获取View宽高的三种方式"></a>Activity获取View宽高的三种方式</h2><h2 id="LruCache缓存机制"><a href="#LruCache缓存机制" class="headerlink" title="LruCache缓存机制"></a>LruCache缓存机制</h2><h2 id="SharedPreferences优缺点，如何优化"><a href="#SharedPreferences优缺点，如何优化" class="headerlink" title="SharedPreferences优缺点，如何优化"></a>SharedPreferences优缺点，如何优化</h2><h2 id="ListView、RecyclerView区别"><a href="#ListView、RecyclerView区别" class="headerlink" title="ListView、RecyclerView区别"></a>ListView、RecyclerView区别</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Activity&quot;&gt;&lt;a href=&quot;#Activity&quot; class=&quot;headerlink&quot; title=&quot;Activity&quot;&gt;&lt;/a&gt;Activity&lt;/h1&gt;&lt;h1 id=&quot;Fragment&quot;&gt;&lt;a href=&quot;#Fragment&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之Java进阶篇</title>
    <link href="https://zzming.cn/post/2615f0a7.html"/>
    <id>https://zzming.cn/post/2615f0a7.html</id>
    <published>2022-06-07T07:12:11.000Z</published>
    <updated>2022-06-13T03:04:10.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的内存分配"><a href="#JVM的内存分配" class="headerlink" title="JVM的内存分配"></a>JVM的内存分配</h1><blockquote><p>Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存划分为不同的数据区域。</p></blockquote><ul><li>java文件首先需要经过编译器编译，生成class字节码文件；</li><li>Java程序中访问这个类时，需要通过ClassLoader(类加载器)将class文件加载到JVM的内存中。</li><li>JVM中的内存可以划分为若干个不同的数据区域，主要分为：<span class='p red'>虚拟机栈、本地方法栈、堆、方法区、程序计数器</span>。</li></ul><p><img src="https://fastly.jsdelivr.net/gh/zzmgoing/assets@main/img/jvm_ing.webp" alt="JVM的内存分配图"></p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><blockquote><p>虚拟机栈是线程私有的，与线程的生命周期同步。</p></blockquote><p>虚拟机栈的初衷是<span class='p red'>用来描述Java方法执行的内存模型</span>，每个方法被执行的时候，JVM都会在虚拟机栈中创建一个栈帧。</p><p>一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等。</p><ul><li><span class='p red'>局部变量表</span>：是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中。</li><li><span class='p red'>操作数栈</span>：（Operand Stack）也常称为操作栈，它是一个后入先出栈（LIFO）。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。在方法执行的过程中，会有各种字节码指令被压入和弹出操作数栈。</li><li><span class='p red'>动态连接</span>：主要目的是为了支持方法调用过程中的动态连接（Dynamic Linking）。在一个 class 文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用，而符号引用存在于方法区中。</li><li><span class='p red'>返回地址</span>：作用是无论当前方法采用何种方式退出（正常退出/异常退出），在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复它的上层方法执行状态。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及 JNI 可能接触本地方法栈多一些，在有些虚拟机的实现中已经将两个合二为一了（比如HotSpot）。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 堆（Heap）是 JVM 所管理的内存中最大的一块，该区域唯一目的就是<span class='p red'>存放对象实例</span>，几乎所有对象的实例都在堆里面分配，因此它也是 Java 垃圾收集器（GC）管理的主要区域，有时候也叫作”GC 堆”。<br>同时它也是所有<span class='p red'>线程共享</span>的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。</p><p>按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old），其中新生代又被划分为 Eden 和 Survivor 区。不同的区域存放具有不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）也是 JVM 规范里规定的一块运行时数据区。方法区主要是存储已经被<span class='p red'>JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据</span>。该区域同堆一样，也是被各个<span class='p red'>线程共享</span>的内存区域。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><blockquote><p>程序计数器是虚拟机中一块较小的内存空间，<span class='p red'>主要用于记录当前线程执行的位置</span>。</p></blockquote><p>Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用（分支操作、循环操作、跳转、异常处理）。</p><ul><li>在Java虚拟机规范中，对程序计数器这一区域<span class='p red'>没有规定任何OutOfMemoryError</span>情况。</li><li>它是<span class='p red'>线程私有</span>的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li><li>当一个线程正在执行一个Java方法的时候，这个计数器记录的是<span class='p red'>正在执行的虚拟机字节码指令的地址</span>。如果正在执行的是Native方法，这个计数器值则为空（Undefined）。</li></ul><h1 id="GC垃圾回收机制"><a href="#GC垃圾回收机制" class="headerlink" title="GC垃圾回收机制"></a>GC垃圾回收机制</h1><blockquote><p>垃圾回收指的是JVM回收内存中已经没有用的对象（垃圾）。</p></blockquote><p>不同的虚拟机实现有着不同的 GC 实现机制，但是一般情况下每一种 GC 实现都会在以下两种情况下触发垃圾回收：</p><ul><li>Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC。</li><li>System.gc()：在应用层，Java 开发工程师可以主动调用此 API 来请求一次 GC。</li></ul><h2 id="如何识别垃圾"><a href="#如何识别垃圾" class="headerlink" title="如何识别垃圾"></a>如何识别垃圾</h2><p>JVM通过<span class='p red'>可达性分析算法</span>来标识垃圾，首先通过GC Root作为起始点，然后向下进行搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><p>可以作为GC Root的对象：</p><ol><li>Java 虚拟机栈（局部变量表）中引用的对象。  </li><li>方法区中静态引用指向的对象。  </li><li>仍处于存活状态中的线程对象。  </li><li>Native 方法中 JNI 引用的对象。</li></ol><h2 id="如何回收垃圾"><a href="#如何回收垃圾" class="headerlink" title="如何回收垃圾"></a>如何回收垃圾</h2><p>通过垃圾回收算法:</p><ol><li><span class='p red'>标记清除算法（Mark and Sweep GC）</span>从”GC Roots”集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收。</li><li><span class='p red'>标记-压缩算法 (Mark-Compact)</span>需要先从根节点开始对所有可达对象做一次标记，之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。最后，清理边界外所有的空间。</li><li><span class='p red'>复制算法（Copying）</span>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中。之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</li></ol><h2 id="JVM分代回收策略"><a href="#JVM分代回收策略" class="headerlink" title="JVM分代回收策略"></a>JVM分代回收策略</h2><p>Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为<span class='p red'>新生代、老年代</span>，这就是 JVM 的内存分代策略。<br>注意: 在<span class='p blue'>HotSpot</span>中除了新生代和老年代，还有<span class='p blue'>永久代</span>。</p><p>分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。</p><h1 id="ClassLoader加载机制"><a href="#ClassLoader加载机制" class="headerlink" title="ClassLoader加载机制"></a>ClassLoader加载机制</h1><blockquote><p>在 Java 程序启动的时候，并不会一次性加载程序中所有的 .class 文件，而是在程序的运行过程中，动态地加载相应的类到内存中。</p></blockquote><p>通常情况下，Java程序中的class文件会在以下2种情况下被ClassLoader主动加载到内存中：</p><ol><li>调用类构造器</li><li>调用类中的静态（static）变量或者静态方法</li></ol><p>JVM 中自带 3 个类加载器：</p><ol><li>启动类加载器：<span class='p red'>BootstrapClassLoader</span></li><li>扩展类加载器：<span class='p red'>ExtClassLoader</span>（JDK 1.9 之后，改名为 <span class='p blue'>PlatformClassLoader</span>）</li><li>系统加载器：<span class='p red'>APPClassLoader</span></li></ol><h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p>所谓双亲委派模式就是，当类加载器收到加载类或资源的请求时，通常都是先委托给父类加载器加载，也就是说，只有当父类加载器找不到指定类或资源时，自身才会执行实际的类加载过程。</p><p>这么设计的原因是为了防止危险代码的植入，比如String类，如果在AppClassLoader就直接被加载，就相当于会被篡改了，所以都要经过老大，也就是BootstrapClassLoader进行检查，已经加载过的类就不需要再去加载了。</p><p>举例：JVM加载HelloWorld.class，默认情况下，JVM首先使用AppClassLoader去加载HelloWorld.Class类。</p><ol><li>AppClassLoader 将加载的任务委派给它的父类加载器（parent）— ExtClassLoader。</li><li>ExtClassLoader 的 parent 为 null，所以直接将加载任务委派给 BootstrapClassLoader。</li><li>BootstrapClassLoader 在 jdk/lib 目录下无法找到 HelloWorld.Class 类，因此返回的 Class 为 null。</li><li>因为 parent 和 BootstrapClassLoader 都没有成功加载 HelloWorld.Class 类，所以AppClassLoader会调用自身的 findClass 方法来加载 HelloWorld.Class。</li></ol><h1 id="Class类的加载过程"><a href="#Class类的加载过程" class="headerlink" title="Class类的加载过程"></a>Class类的加载过程</h1><blockquote><p>class文件被加载到内存中所经过的详细过程，主要分 3 大步：<span class='p red'>装载、链接、初始化</span>。其中链接中又包含<span class='p blue'>验证、准备、解析</span> 3 小步。</p></blockquote><h2 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h2><p>查找字节流，并根据此字节流创建类的过程。装载过程成功的标志就是在方法区中成功创建了类所对应的 Class 对象。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>验证创建的类，并将其解析到 JVM 中使之能够被 JVM 执行。</p><ul><li><span class='p red'>验证</span>：文件格式检验、元数据检验、字节码检验、符号引用检验。</li><li><span class='p red'>准备</span>：为类中的静态变量分配内存，并为其设置“0值”。基本类型的默认值为 0；引用类型默认值是 null。</li><li><span class='p red'>解析</span>：把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM 会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>将标记为 static 的字段进行赋值，并且执行 static 标记的代码语句。没有 static 修饰的语句块在实例化对象的时候才会执行。</p><h1 id="线程、多线程、线程池"><a href="#线程、多线程、线程池" class="headerlink" title="线程、多线程、线程池"></a>线程、多线程、线程池</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote><p>线程就是进程中运行的多个子任务，是操作系统调用的最小单元。</p></blockquote><p>线程状态：初始、运行、阻塞、等待、超时等待、终止。</p><ul><li>初始(NEW)： 新创建了一个线程对象，但还没有调用start()方法。</li><li>运行(RUNNABLE)： Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li>阻塞(BLOCKED)： 表示线程阻塞于锁。</li><li>等待(WAITING)： 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>超时等待(TIMED_WAITING)： 该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>终止(TERMINATED)： 表示该线程已经执行完毕。</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote><p>在一个应用程序中执行多个线程操作，同步完成多项任务就叫做多线程。多线程是为了提高资源使用效率。</p></blockquote><p>多线程实现方式：</p><ol><li>Thread、Handler配合使用</li><li>AsyncTask、HandlerThread、IntentService</li><li>线程池ThreadPool</li></ol><h2 id="多线程三个特性"><a href="#多线程三个特性" class="headerlink" title="多线程三个特性"></a>多线程三个特性</h2><ol><li><span class='p red'>原子性</span>：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。<br>比如，对于一个静态全局变量int i，两个线程同时对它赋值，线程A给他赋值为1，线程B给他赋值为-1。那么不管这两个线程以何种方式，何种步调工作，i的值要么是1，要么是-1，线程A和线程B之间是没有干扰的。这就是原子性的一个特点，不可被中断。</li><li><span class='p red'>可见性</span>：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性问题是不存在的。</li><li><span class='p red'>有序性</span>：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</li></ol><h2 id="常见的四类功能线程池"><a href="#常见的四类功能线程池" class="headerlink" title="常见的四类功能线程池"></a>常见的四类功能线程池</h2><ol><li>定长线程池（FixedThreadPool）</li><li>定时线程池（ScheduledThreadPool）</li><li>可缓存线程池（CachedThreadPool）</li><li>单线程化线程池（SingleThreadExecutor）</li></ol><p><img src="https://fastly.jsdelivr.net/gh/zzmgoing/assets@main/img/xianchengchi.webp" alt="常见四类线程池"></p><h2 id="线程池的作用和优点"><a href="#线程池的作用和优点" class="headerlink" title="线程池的作用和优点"></a>线程池的作用和优点</h2><p>线程池的主要作用是用于<span class='p red'>管理子线程</span>，优点有：</p><ol><li>复用线程池中的线程，避免频繁创建和销毁线程所带来的内存开销。</li><li>有效控制线程的最大并发数，避免因线程之间抢占资源而导致的阻塞现象。</li><li>能够对线程进行简单的管理，提供定时执行以及指定时间间隔循环执行等功能。</li></ol><h1 id="锁、死锁"><a href="#锁、死锁" class="headerlink" title="锁、死锁"></a>锁、死锁</h1><p>锁的分类：</p><ul><li>公平锁/非公平锁（公平锁是指多个线程按照申请锁的顺序来获取锁）</li><li>可重入锁（又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁）</li><li>独享锁/共享锁（独享锁是指该锁一次只能被一个线程所持有）</li><li>互斥锁/读写锁（ReentrantLock/ReadWriteLock）</li><li>乐观锁/悲观锁（悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。）</li><li>分段锁（分段锁其实是一种锁的设计，并不是具体的一种锁）</li><li><span class='p green'>偏向锁/轻量级锁/重量级锁（这三种锁是指锁的状态，并且是针对Synchronized）</span></li><li>自旋锁（自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU）</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized提供了<span class='p red'>同步锁的概念</span>，被synchronized修饰的代码段可以防止被多个线程同时执行，必须一个线程把synchronized修饰的代码段都执行完毕了，其他的线程才能开始执行这段代码。<br>因为synchronized保证了在同一时刻，只能有一个线程执行同步代码块，所以执行同步代码块的时候相当于是单线程操作了，那么线程的可见性、原子性、有序性（线程之间的执行顺序）它都能保证了。</p><p>synchronized可以用来修饰以下3个层面：修饰实例方法；修饰静态类方法；修饰代码块。</p><ol><li><span class='p red'>修饰实例方法</span>：锁是当前对象，只有同一个实例对象调用方法才会产生互斥效果，不同实例对象之间不会产生互斥效果。</li><li><span class='p red'>修饰静态类方法</span>：锁是当前类的Class对象，即使在不同线程中调用不同实例对象，也会有互斥效果。</li><li><span class='p red'>修饰代码块</span>：synchronized 作用于代码块时，锁对象就是跟在后面括号中的对象。任何Object对象都可以当作锁对象。</li></ol><h3 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h3><ol><li>无法判断获取锁的状态。</li><li>当持有锁的方法执行时间过长时就会一直占着锁不释放，导致其他使用同一锁的方法无法执行，必须等待，导致速度，效率减小。</li><li>当多个线程尝试获取锁的时候，未获取到锁的线程会不断尝试去获取锁而不会发生中断，这样会造成性能消耗。</li><li>有可能产生死锁，导致程序中断。</li></ol><h3 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h3><ol><li><p>锁膨胀（锁升级）<br>锁膨胀是指 synchronized 从<span class='p red'>无锁</span>升级到<span class='p red'>偏向锁</span>，再到<span class='p red'>轻量级锁</span>，最后到<span class='p red'>重量级锁</span>的过程，它叫锁膨胀也叫锁升级。<br>JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从<span class='p red'>用户态转换成内核态</span>，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能。</p></li><li><p>锁消除<br>锁消除指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。<br>锁消除的依据是<span class='p red'>逃逸分析</span>的数据支持，如 StringBuffer 的 append() 方法，或 Vector 的 add() 方法，在很多情况下是可以进行锁消除的。<br>比如在一个方法里面定义了一个局部变量StringBuffer，因为这个局部变量不会从该方法中逃逸出去，此时我们可以使用锁消除（不加锁）来加速程序的运行。</p></li><li><p>锁粗化<br>锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。<br>锁粗化的作用：如果检测到同一个对象执行了连续的加锁和解锁的操作，则会将这一系列操作合并成一个更大的锁，从而提升程序的执行效率。</p></li><li><p>自适应自旋锁<br>自旋锁是指通过自身循环，尝试获取锁的一种方式。<br>自旋锁优点在于它<span class='p red'>避免一些线程的挂起和恢复操作</span>，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程度上避免线程挂起和恢复所造成的性能开销。<br>如果长时间自旋还获取不到锁，那么也会造成一定的资源浪费，所以我们通常会给自旋设置一个固定的值来避免一直自旋的性能开销。</p><span class='p red'>自适应自旋锁</span>是指：线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数。<span class='p red'>如果线程自旋成功了，则下次自旋的次数会增多，如果失败，下次自旋的次数会减少。</span></li></ol><p>其中锁膨胀和自适应自旋锁是 synchronized 关键字自身的优化实现，而锁消除和锁粗化是 JVM 虚拟机对 synchronized 提供的优化方案。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>其实volatile关键字的作用就是保证了可见性和有序性（<span class='p red'>不保证原子性</span>），如果一个共享变量被volatile关键字修饰，那么如果一个线程修改了这个共享变量后，其他线程是立马可知的。</p><p>volatile能禁止指令重新排序，在指令重排序优化时，在volatile变量之前的指令不能在volatile之后执行，在volatile之后的指令也不能在volatile之前执行，所以它保证了有序性。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock的实现是一种<span class='p red'>自旋锁</span>，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。</p><p>ReentrantLock 的使用同 synchronized 有点不同，它的加锁和解锁操作都需要手动完成。<span class='p red'>lock() 和 unlock()</span>。</p><p>默认情况下，synchronized 和 ReentrantLock 都是非公平锁。<br>但是 ReentrantLock 可以通过传入 true 来创建一个公平锁。所谓公平锁就是通过同步队列来实现多个线程按照申请锁的顺序获取锁。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁发生的四个必要条件</p><ol><li>资源互斥使用。</li><li>多个进程(线程)保持一定的资源，但又请求新的资源。</li><li>资源不可被剥夺。</li><li>多个进程循环等待。</li></ol><p>一般死锁的应对策略有</p><ol><li>死锁预防：如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。</li><li>死锁避免：如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。</li><li>死锁处理：破坏四个必要条件的其中一个，比如kill掉一个进程。</li><li>死锁忽略：不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。</li></ol><h1 id="常见面试题锦集"><a href="#常见面试题锦集" class="headerlink" title="常见面试题锦集"></a>常见面试题锦集</h1><h2 id="Class类的加载执行顺序-包含静态变量和方法"><a href="#Class类的加载执行顺序-包含静态变量和方法" class="headerlink" title="Class类的加载执行顺序(包含静态变量和方法)"></a>Class类的加载执行顺序(包含静态变量和方法)</h2><p>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p><ol><li>父类静态变量和静态代码块；</li><li>子类静态变量和静态代码块；</li><li>父类普通成员变量和普通代码块；</li><li>父类的构造函数；</li><li>子类普通成员变量和普通代码块；</li><li>子类的构造函数。</li></ol><h2 id="如何停止正在运行的线程"><a href="#如何停止正在运行的线程" class="headerlink" title="如何停止正在运行的线程"></a>如何停止正在运行的线程</h2><ol><li>使用thread.interrupt()方法停止线程，可使用isInterrupted()方法配合return终止向下执行。</li><li>使用退出标志，使线程正常退出，也就是run()方法执行完后终止。</li><li>使用抛异常的方式终止执行，上层可以通过try-catch捕获异常。</li><li>使用stop()方法强行终止，但是不推荐，因为不安全已经废弃。</li></ol><h2 id="线程池ThreadPool的构造函数"><a href="#线程池ThreadPool的构造函数" class="headerlink" title="线程池ThreadPool的构造函数"></a>线程池ThreadPool的构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建线程池</span></span><br><span class="line"><span class="comment">// 创建时，通过配置线程池的参数，从而实现自己所需的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">        TimeUnit unit,</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">        RejectedExecutionHandler handler)</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(...);</span><br><span class="line"><span class="comment">// 2. 向线程池提交任务：execute</span></span><br><span class="line">threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ... <span class="comment">// 线程执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">threadPool.shutdown(); <span class="comment">// 3. 关闭线程池shutdown() </span></span><br><span class="line"><span class="comment">// 关闭线程的原理</span></span><br><span class="line"><span class="comment">// a. 遍历线程池中的所有工作线程</span></span><br><span class="line"><span class="comment">// b. 逐个调用线程的interrupt()中断线程（注：无法响应中断的任务可能永远无法终止）</span></span><br><span class="line"><span class="comment">// 也可调用shutdownNow()关闭线程：threadPool.shutdownNow（）</span></span><br><span class="line"><span class="comment">// 二者区别：</span></span><br><span class="line"><span class="comment">// shutdown：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程</span></span><br><span class="line"><span class="comment">// shutdownNow：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</span></span><br><span class="line"><span class="comment">// 使用建议：一般调用shutdown()关闭线程池；若任务不一定要执行完，则调用shutdownNow()</span></span><br></pre></td></tr></table></figure><p>构造参数：</p><ol><li><span class='p red'>corePoolSize</span>： 线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</li><li><span class='p red'>maximumPoolSize</span>： 最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。</li><li><span class='p red'>keepAliveTime</span>： 线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。</li><li><span class='p red'>unit</span>： 这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。</li><li><span class='p red'>workQueue</span>： 一个阻塞队列，提交的任务将会被放到这个队列里。</li><li><span class='p red'>threadFactory</span>： 线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。</li><li><span class='p red'>handler</span>： 拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。</li></ol><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ol><li><span class='p red'>地址空间</span>：进程之间是独立的地址空间，同一进程里的线程共享本进程的地址空间。</li><li><span class='p red'>资源拥有</span>：进程之间的资源是独立的，同一进程里的线程共享本进程的资源(如内存，I/O，CPU，用户存储)。</li><li><span class='p red'>健壮性</span>：一个进程崩溃后不会对其他进程产生影响，但是一个线程崩溃会导致整个进程死掉，所以多进程比多线程健壮。</li><li><span class='p red'>资源占用</span>：进程间切换时，消耗的资源大，效率不高，所以当要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</li><li><span class='p red'>执行过程</span>：每个独立的进程有一个程序运行的入口，顺序执行序列。但是线程不能独立执行，必须依存于应用程序中。</li><li>线程是处理器调度的基本单位，进程不是。</li><li>两者都可以并发执行。</li></ol><h2 id="volatile的作用，能否保证线程安全"><a href="#volatile的作用，能否保证线程安全" class="headerlink" title="volatile的作用，能否保证线程安全"></a>volatile的作用，能否保证线程安全</h2><p>volatile只能作用于变量，能够禁止指令重排，保证可见性和有序性。<br>因为不能保证原子性，所以volatile不能保证线程安全。</p><h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><ol><li>volatile只能作用于变量，使用范围较小，synchronized可以用在方法、类、同步代码块等，使用范围比较广。</li><li>volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以保证。</li><li>volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。</li></ol><h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><ol><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。</li><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM的内存分配&quot;&gt;&lt;a href=&quot;#JVM的内存分配&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存分配&quot;&gt;&lt;/a&gt;JVM的内存分配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中，会把它所管理的内存</summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之Java基础篇</title>
    <link href="https://zzming.cn/post/49d5b74.html"/>
    <id>https://zzming.cn/post/49d5b74.html</id>
    <published>2022-06-06T07:11:38.000Z</published>
    <updated>2022-06-12T13:36:14.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特点和特性"><a href="#特点和特性" class="headerlink" title="特点和特性"></a>特点和特性</h1><p>Java特点：跨平台、面向对象、安全性、多线程、简单易用、可维护性高。</p><div class="table-container"><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td>跨平台</td><td>Java可以不受计算机的硬件和操作系统的限制，而独立于平台。因为Java中有自带的JVM，它执行经过javac命令编译完成的java源代码所生成的class文件转换成机器码语言在平台上操作。</td></tr><tr><td>面向对象</td><td>万物皆对象，Java以对象为基本粒度。对象中包含属性和方法，对象的说明用属性来表达，方法用来操作对象。这样可以对应用程序进行解耦，提高代码的可扩展性和重用性。</td></tr><tr><td>安全性</td><td>语言级安全性：Java的数据结构是完整的对象，这些封装过的数据类型具有安全性。<br>编译时安全性：编译时要进行Java语义和语法的检查，保证每个变量对应一个相应的值，编译后生成Java类。<br>运行时安全性：表示在运行Java类时要进行字节码校检器校检之后才可以运行。<br>可执行代码安全性：Java类在网络上使用时，对它的权限进行了设置，保证了被访问用户的安全性。</td></tr><tr><td>多线程</td><td>多线程是指允许一个应用程序同时存在两个或两个以上的线程，用于支持事务并发和多任务处理。<br>Java除了内置的多线程技术之外，还定义了一些类、方法等来建立和管理用户定义的多线程。</td></tr><tr><td>简单易用</td><td>就是指java源代码可以不用在特定环境下编写。</td></tr><tr><td>可维护性高</td><td>—</td></tr></tbody></table></div><p>四大特性：继承、封装、多态、抽象。</p><div class="table-container"><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>继承</td><td>继承要有一定的层次结构，还要具备一定的可传递性;<br>子类只能继承父类<span class='p red'>非私有化</span>的成员变量和方法；<br>实行<span class='p red'>就近原则</span>，有局部变量优先使用局部变量，没有就使用子类成员变量，子类没有则使用父类成员变量。</td></tr><tr><td>封装</td><td>将抽象出来的属性和方法写在一个类中就是封装，将不需要对外提供的内容隐藏起来，提供公共的访问方式；<br>封装就是包装的过程，但封装不是绝对的封装，如果其他程序要获取已经封装好的数据，就要通过程序指定的接口或方法才能获取。</td></tr><tr><td>多态</td><td>多态是同一个行为具有多个不同表现形式或形态的能力；<br>多态就是同一个接口，使用不同的实例而执行不同操作；<br>多态性是对象多种表现形式的体现。</td></tr><tr><td>抽象</td><td>就是对同一类事物共有的属性（特征）和方法（功能/行为）进行抽取、归纳、总结；<br>抽象类不能实例化为一个对象，就比如水果是苹果，香蕉，梨等一类事物抽象出来的。</td></tr></tbody></table></div><h1 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h1><p>面向对象：指的是将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，然后通过互相调用，解决组合问题；<br>也就是说在进行面向对象编程的时候，要把属性、行为等封装成对象，然后基于这些对象的能力进行业务逻辑的实现。</p><p>面向过程：指的是把问题分解成一个一个步骤，每个步骤用函数来实现，然后依次调用即可。</p><h1 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h1><p>Java 的两大数据类型：内置数据类型、引用数据类型。</p><div class="table-container"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>内置数据类型</td><td>byte、short、int、long、float、double、boolean、char</td></tr><tr><td>引用数据类型</td><td>引用类型指向一个对象，<span class='p red'>指向对象的变量是引用变量</span>。<br>对象、数组都是引用数据类型，所有引用类型的默认值都是<span class='p red'>null</span>。</td></tr></tbody></table></div><p>八大基本数据类型占用空间和范围：</p><div class="table-container"><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表示范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节</td><td>-2^7 ~ 2^7 - 1（-128 ~ 127）</td></tr><tr><td>short</td><td>2字节</td><td>-2^15 ~ 2^15 - 1（-32768 ~ 32767）</td></tr><tr><td>int</td><td>4字节</td><td>-2^31 ~ 2^31 - 1（-2147483648 ~ 2147483647）</td></tr><tr><td>long</td><td>8字节</td><td>-2^63 ~ 2^63 - 1</td></tr><tr><td>float</td><td>4字节</td><td>-3.403E38 ~ 3.403E38</td></tr><tr><td>double</td><td>8字节</td><td>-1.798E308 ~ 1.798E308</td></tr><tr><td>boolean</td><td>1字节</td><td>true、false</td></tr><tr><td>char</td><td>2字节</td><td>0 ~ 65535</td></tr></tbody></table></div><h1 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h1><blockquote><p>从Java SE2开始，就提供了四种类型的引用：强引用、软引用、弱引用和虚引用。<br>Java中提供这四种引用类型主要有两个目的：<br>1、通过代码的方式决定某些对象的生命周期；<br>2、有利于JVM进行垃圾回收。</p></blockquote><div class="table-container"><table><thead><tr><th>类别</th><th>回收机制</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从不回收</td><td>对象状态</td><td>JVM停止运行时</td></tr><tr><td>软引用</td><td>内存不足时回收</td><td>缓存</td><td>内存不足</td></tr><tr><td>弱引用</td><td>对象不被引用时回收</td><td>缓存</td><td>GC运行后</td></tr><tr><td>虚引用</td><td>对象被回收时</td><td>管理控制精确内存稳定性</td><td>unknown</td></tr></tbody></table></div><h1 id="常见面试题锦集"><a href="#常见面试题锦集" class="headerlink" title="常见面试题锦集"></a>常见面试题锦集</h1><h2 id="equals方法和-的区别"><a href="#equals方法和-的区别" class="headerlink" title="equals方法和==的区别"></a>equals方法和==的区别</h2><ol><li><p>对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；<br>如果作用于引用类型的变量，则比较的是所指向的对象的地址。</p></li><li><p>对于equals方法，注意：equals方法不能作用于基本数据类型的变量;<br>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；<br>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p></li></ol><h2 id="String、StringBuilder和StringBuffer区别"><a href="#String、StringBuilder和StringBuffer区别" class="headerlink" title="String、StringBuilder和StringBuffer区别"></a>String、StringBuilder和StringBuffer区别</h2><ul><li>String、StringBuffer是线程安全的，StringBuilder是非线程安全。</li><li>StringBuffer与StringBuilder的对象存储在堆中，String对象存储在Constant String Pool(字符串常量池)。</li><li>StringBuffer和StringBuilder是可变对象，String一旦创建无法修改，并且String是线程安全的。</li></ul><h2 id="为什么String不可变，不可变对象的好处"><a href="#为什么String不可变，不可变对象的好处" class="headerlink" title="为什么String不可变，不可变对象的好处"></a>为什么String不可变，不可变对象的好处</h2><p>主要是为了安全。<br>不可变对象的好处主要也是保证了线程安全。</p><p>由于String广泛用于java类中的参数，所以安全是非常重要的考虑点。包括线程安全，打开文件，存储数据密码等等。<br>因为java字符串是不可变的，可以在java运行时<span class='p red'>节省大量java堆空间</span>。因为不同的字符串变量可以引用池中的相同的字符串。如果字符串是可变得话，任何一个变量的值改变，就会反射到其他变量，那字符串池也就没有任何意义了。<br>String的不变性保证哈希码始终一，所以在用于HashMap等类的时候就不需要重新计算哈希码，提高效率。</p><h2 id="final、finally、finalize区别"><a href="#final、finally、finalize区别" class="headerlink" title="final、finally、finalize区别"></a>final、finally、finalize区别</h2><ol><li><span class='p blue'>final</span>：修饰类，方法，变量（表示不可变）。</li><li><span class='p blue'>finally</span>：finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（<span class='p red'>不管有没有抛出异常</span>），经常被用在需要释放资源的情况下。</li><li><span class='p blue'>finalize</span>：finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。</li></ol><h2 id="Exception和Error有什么区别"><a href="#Exception和Error有什么区别" class="headerlink" title="Exception和Error有什么区别"></a>Exception和Error有什么区别</h2><blockquote><p>首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。<br>Exception和Error体现了JAVA这门语言对于异常处理的两种方式。</p></blockquote><ul><li>Exception是java程序运行中<span class='p red'>可预料</span>的异常情况，我们<span class='p red'>可以捕获</span>到这种异常，并且对这种异常进行业务外的处理。</li><li>Error是java程序运行中<span class='p red'>不可预料</span>的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常<span class='p red'>不能被捕获到</span>，比如OutOfMemoryError、NoClassDefFoundError等。</li></ul><p>其中的Exception又分为<span class='p red'>检查性异常</span>和<span class='p red'>非检查性异常</span>。</p><ul><li>检查性异常必须在编写代码时，使用try catch捕获（比如：IOException异常）。</li><li>非检查性异常在代码编写时，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。</li></ul><h2 id="RunTimeException和其他Exception区别"><a href="#RunTimeException和其他Exception区别" class="headerlink" title="RunTimeException和其他Exception区别?"></a>RunTimeException和其他Exception区别?</h2><p>其他Exception，受检查异常。可以理解为错误，必须要开发者解决以后才能编译通过，解决的方法有两种：<span class='p red'>throw到上层</span>或<span class='p red'>try-catch处理</span>。<br>RunTimeException：运行时异常，又称不受检查异常，不受检查！不受检查！！不受检查！！！<br>重要的事情说三遍，因为不受检查，所以在代码中可能会有RunTimeException时Java编译检查时不会告诉你有这个异常，但是在实际运行代码时则会暴露出来，比如经典的1/0，空指针等。如果不处理也会被Java自己处理。</p><h2 id="泛型和类型擦除"><a href="#泛型和类型擦除" class="headerlink" title="泛型和类型擦除"></a>泛型和类型擦除</h2><blockquote><p>泛型简单说就是能广泛适用的类型。<br>还有一种较为准确的说法就是为了参数化类型，就是可以将类型当作参数传递给一个类或者是方法。</p></blockquote><ul><li>因为泛型可以使数据的类别像参数一样由外部传递进来，它提供了一种扩展能力，更符合抽象开发。</li><li>当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。</li><li>泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换。</li></ul><p>泛型类中的类型参数与泛型方法中的类型参数是没有相应的联系的，<span class='p red'>泛型方法始终以自己定义的类型参数为准</span>。</p><h3 id="通配符-？"><a href="#通配符-？" class="headerlink" title="通配符 ？"></a>通配符 ？</h3><p>通配符的出现是为了指定泛型中的类型范围。</p><ul><li>&lt;?&gt;被称作无限定的通配符，会被转译为Object类型。</li><li>&lt;? extends T&gt;被称作有上限的通配符，会被转译为T的类型。</li><li>&lt;? super T&gt;被称作有下限的通配符。</li></ul><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><blockquote><p>泛型信息只存在于代码编译期间，在编译器编译生成字节码后，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。</p></blockquote><p>在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 <T>则会被转译成普通的 Object 类型，如果指定了上限如 <T extends String>则类型参数就被替换成类型上限。</p><p>泛型类或者泛型方法中，不接受8种基本数据类型如int、boolean等，而是需要使用它们的包装类Integer、Boolean等。</p><p><strong>为什么会有类型擦除？</strong></p><p>这是Java实现泛型的方式，也叫作<em>伪泛型</em>。</p><p>Java的泛型在底层实现上使用了Object引用，编译器可以通过指定的泛型进行静态类型检查，在编译后又擦除为Object类型。<br>如果要实现真泛型的话，就需要修改JVM的源码，让虚拟机正确地读取和校验泛型信息，而之前的Java是没有这一概念的。<br>所以为了兼容旧程序，还需要为原本不支持泛型的API添加一套泛型API。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/104600952">Java 泛型与类型擦除</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特点和特性&quot;&gt;&lt;a href=&quot;#特点和特性&quot; class=&quot;headerlink&quot; title=&quot;特点和特性&quot;&gt;&lt;/a&gt;特点和特性&lt;/h1&gt;&lt;p&gt;Java特点：跨平台、面向对象、安全性、多线程、简单易用、可维护性高。&lt;/p&gt;
&lt;div class=&quot;table-</summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android面试之网络篇</title>
    <link href="https://zzming.cn/post/a3e07e13.html"/>
    <id>https://zzming.cn/post/a3e07e13.html</id>
    <published>2022-06-05T06:40:51.000Z</published>
    <updated>2022-06-12T13:36:21.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h1><blockquote><p>TCP（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务。<br>即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p><p>UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的传输层协议。<br>UDP不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。</p></blockquote><p>TCP和UDP的相同点：都是<strong>传输层</strong>协议。</p><p>TCP和UDP的不同点：<strong>报头不同、特点不同、协议不同</strong>。</p><div class="table-container"><table><thead><tr><th>不同点</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>报头不同</td><td>报头最大长度60个字节</td><td>UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号</td></tr><tr><td>特点不同</td><td><span class='p red'>面向连接：</span>客户端和服务端的三次握手，四次挥手<br><span class='p red'>可靠传输：</span>序列号，确认应答机制，超时重传，拥塞控制<br><span class='p red'>面向字节流：</span>创建一个TCP的Socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做全双工</td><td><span class='p red'>无连接：</span>知道对端的IP和端口号就能直接进行传输, 不需要建立连接<br><span class='p red'>不可靠：</span>没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息<br><span class='p red'>面向数据报：</span>不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并<br><span class='p red'>数据接收不够灵活：</span>但是能够明确区分两个数据包，避免粘包问题</td></tr><tr><td>协议不同</td><td><strong>HTTP</strong>(超文本传输协议)、<strong>HTTPS</strong>(超文本传输安全协议)、<strong>SSH</strong>(安全外壳协议)、<strong>Telnet</strong>(电信网络协议)、<strong>FTP</strong>(文件传输协议)、<strong>SMTP</strong>(简单邮件传输协议)</td><td><strong>NFS</strong>(网络文件系统)、<strong>TFTP</strong>(简单文件传输协议)、<strong>DHCP</strong>(动态主机配置协议)、<strong>BOOTP</strong>(启动协议, 用于无盘设备启动)、<strong>DNS</strong>(域名解析协议)</td></tr></tbody></table></div><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>TCP/IP一般指的是TCP/IP协议簇，主要包括了多个不同网络间实现信息传输涉及到的各种协议。主要包括以下几层：</p><ul><li>应用层：主要提供数据和服务。比如HTTP，FTP，DNS等</li><li>传输层：负责数据的组装，分块。比如TCP，UDP等</li><li>网络层：负责告诉通信的目的地，比如IP等</li><li>数据链路层：负责连接网络的硬件部分，比如以太网，WIFI等</li></ul><h2 id="TCP沾包问题"><a href="#TCP沾包问题" class="headerlink" title="TCP沾包问题"></a>TCP沾包问题</h2><p>首先要明确，粘包问题中的<em>包</em>，是指的应用层的数据包。</p><ul><li>在TCP的协议头中，没有如同UDP一样的<em>报文长度</em>这样的字段，但是有一个序号这样的字段；  </li><li>站在传输层的角度，TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；  </li><li>站在应用层的角度，看到的只是一串连续的字节数据，那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。  </li></ul><p>解决方案：<strong>明确两个包之间的边界。</strong></p><ol><li>对于定长的包，保证每次都按固定大小读取即可;  </li><li>对于变长的包，可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;  </li><li>对于变长的包，还可以在包和包之间使用明确的分隔符；  </li><li>TLV格式的数据传输。</li></ol><h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><blockquote><p>Http：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>Https：是以安全为目标的HTTP通道，简单讲是Http的安全版，即Http下加入SSL层，Https的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><p>HTTP-TCP-IP</p><p>HTTPS-<span class='p red'>SSL或TLS</span>-TCP-IP</p><ul><li>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</li><li>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2、TLS 1.3  四个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。目前使用最广泛的是TLS 1.1、TLS 1.2、TLS 1.3。</li></ul><h2 id="Http和Https的不同点"><a href="#Http和Https的不同点" class="headerlink" title="Http和Https的不同点"></a>Http和Https的不同点</h2><div class="table-container"><table><thead><tr><th>区别</th><th>Http</th><th>Https</th></tr></thead><tbody><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>证书</td><td>不需要</td><td>需要到CA申请证书，一般免费证书较少，因而需要一定费用</td></tr><tr><td>传输方式</td><td>明文传输</td><td>具有安全性的ssl加密传输</td></tr><tr><td>安全性</td><td>连接简单，无状态，安全性低</td><td>ssl+http构建的可进行加密传输、身份认证的网络协议，更加安全</td></tr></tbody></table></div><h1 id="HTTP1-0、1-1和2-0的区别"><a href="#HTTP1-0、1-1和2-0的区别" class="headerlink" title="HTTP1.0、1.1和2.0的区别"></a>HTTP1.0、1.1和2.0的区别</h1><h2 id="HTTP1-1相对于1-0的优化"><a href="#HTTP1-1相对于1-0的优化" class="headerlink" title="HTTP1.1相对于1.0的优化"></a>HTTP1.1相对于1.0的优化</h2><ul><li><span class='p red'>缓存的处理：</span>1.0根据header头的expires作为缓存依据，1.1引入了更多的缓存控制策略。（Entity tag、If-match）</li><li><span class='p red'>带宽的优化：</span>1.0请求对象时服务器会返回整个对象，并且不支持断点续传，1.1在请求头加入了range头域，可以请求资源的某一部分，节省了带宽。</li><li><span class='p red'>host处理：</span>1.1中请求和响应都支持host头域，请求中没有的话会报错（400）。支持host头域是因为一个服务器可以部署多个虚拟主机。</li><li><span class='p red'>长链接优化：</span>一个TCP连接可以传送多个HTTP请求和响应，减少了建立多个连接的消耗和延迟，默认打开了keep-alive，一定程度上弥补了1.0每次请求都要重新连接的缺陷。</li></ul><h2 id="HTTP2-0相对于1-x的优化"><a href="#HTTP2-0相对于1-x的优化" class="headerlink" title="HTTP2.0相对于1.x的优化"></a>HTTP2.0相对于1.x的优化</h2><ul><li>HTTP2请求<span class='p red'>报文头部采用二进制格式</span>传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。</li><li>HTTP2的<span class='p red'>多路复用</span>解决了连接效率的问题，在一个TCP连接中可以存在多个流，通过帧中的标识知道属于哪个请求，可以避免HTTP旧版本中的线头阻塞问题，极大的提高了传输效率。</li></ul><p>Http1.0每次请求都会建立一次TCP连接，也就是3次握手4次挥手，这个过程在一次请求中占用了比较长的时间；<br>Http1.1开启了Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题：串行文件传输消耗时间（单通道）、连接数过多服务器承载的最大并发数有限。</p><p><strong>多路复用：</strong></p><ul><li>同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰。</li></ul><h1 id="HTTPS原理和请求过程"><a href="#HTTPS原理和请求过程" class="headerlink" title="HTTPS原理和请求过程"></a>HTTPS原理和请求过程</h1><blockquote><p>因为HTTP有被窃听、被篡改、被冒充的风险，所以我们需要对HTTP请求进行加密，也就是在HTTP下面加入SSL层，进行证书的校验和数据的加密传输。</p></blockquote><p>服务端需要在公认的证书颁发机构（CA）申请证书，证书一般包含了有效期、证书所有者、公钥、签名等信息；<br>当客户端发起HTTPS请求时，服务端需要将证书发送给客户端进行验证，验证通过后才能进行有效的数据传输。</p><ul><li>客户端发起请求时会携带所支持的SSL版本，加密算法和Hash算法等信息；</li><li>服务端接收到请求后会选择加密算法与Hash算法，将自己的身份信息以证书的形式返回给客户端；</li><li>客户端首先会去验证证书的有效性（也就是证书颁发机构），查看是否可信任；</li><li>证书可信则根据本地根证书的<span class='p red'>CA公钥</span>解密服务器证书获得内容和签名，验证签名、域名、有效期等；</li><li>如果验证通过，就使用服务器提供的公钥加密一串随机值发送给服务端；</li><li>服务端接收加密数据后使用私钥进行解密，得到随机值；</li><li>服务端将解密后的随机值作为私钥对数据进行加密（选择的加密算法）然后返回给客户端；</li><li>客户端用这个随机值（私钥）对服务端返回的数据进行解密，完成数据传输。</li></ul><p>Https在传输证书和秘钥的过程中，使用的是非对称加密算法（保证绝对安全）；<br>完成验证后使用的是对称算法进行数据传输（保证传输效率）。</p><h1 id="对称和非对称加密算法"><a href="#对称和非对称加密算法" class="headerlink" title="对称和非对称加密算法"></a>对称和非对称加密算法</h1><div class="table-container"><table><thead><tr><th>描述</th><th>对称加密</th><th>非对称加密</th></tr></thead><tbody><tr><td>特点</td><td>秘钥相同、加解密算法不同</td><td>秘钥不同，加解密算法相同</td></tr><tr><td>算法</td><td>DES，AES算法</td><td>RSA，DSA算法</td></tr><tr><td>优点</td><td>传输效率高</td><td>安全，公钥即使被其他人获知，也无法解密数据</td></tr><tr><td>缺点</td><td>密钥有可能被破解，容易被伪造，传输过程中一旦密钥被其他人获知则可以进行数据解密</td><td>需要通信双方都有一套公钥和私钥</td></tr></tbody></table></div><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>由于公钥是公开的，别人截获到公钥就能伪造数据进行传输，所以我们需要验证数据的来源。<span class='p blue'>在用公钥进行加密后，再用私钥进行一次加密，那么私钥的这次加密就叫做签名</span>。所以传输数据流程就变成了加密数据和签名数据，如果解出来都是同样的数据，那么则数据安全可靠。</p><h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64是一种将二进制数据转换成64种字符组成的字符串的编码算法，主要用于非文本数据的传输，比如图片。可以将图片这种二进制数据转换成具体的字符串，进行保存和传输。</p><p>由于Base64算法是公开的，所以不能算加密算法。</p><h1 id="网络耗时优化"><a href="#网络耗时优化" class="headerlink" title="网络耗时优化"></a>网络耗时优化</h1><ol><li>DNS优化<br>使用HttpDns，即Http协议与自建的DNS服务器交互，获取响应IP，如果有问题的话再降级到运营商的LocalDNS解析。优点就是提升域名解析的速度。</li><li>连接优化<br>HTTP2多路复用，同一个域名使用一个TCP链接就可以完成所有的请求。（HTTP1中并发多个请求需要建立多个TCP链接，HTTP2的多路复用技术代替了原来的序列和阻塞机制）</li><li>域名合并<br>域名过多会使长链接复用效率低，每个域名都需要DNS解析，HTTP请求同时跟多个服务器保持长链接增加了客户端和服务端的资源消耗。<br>所以可以对不同域名进行合并，服务端再通过Header或者参数进行分发，这样可以提升长链接效率，减少DNS解析，减少客户端和服务端资源消耗。</li><li>TLS<br>升级服务器的TLS1.3版本，客户端在Android10和iOS12.2后默认支持TLS1.3，想要低版本支持需要接入三方扩展库。（TLS1.3版本对比1.2版本连接复用率高，提升了性能，废弃了一些相对不安全的算法，提升了安全性）</li><li>数据压缩优化<br>ProtoBuffer是Google出的一种轻量并且高效的数据存储格式，性能比Json好，Size比Json小。</li></ol><blockquote><p><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理</a><br><a href="https://www.imgeek.org/article/825358030">客户端网络优化(一)-原理篇</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP和UDP&quot;&gt;&lt;a href=&quot;#TCP和UDP&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP&quot;&gt;&lt;/a&gt;TCP和UDP&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;TCP（Transmission Control Protocol，传输控</summary>
      
    
    
    
    <category term="Android面试" scheme="https://zzming.cn/categories/Android%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="android" scheme="https://zzming.cn/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Flutter面试之基础篇</title>
    <link href="https://zzming.cn/post/e8e5428c.html"/>
    <id>https://zzming.cn/post/e8e5428c.html</id>
    <published>2022-06-04T04:43:33.000Z</published>
    <updated>2022-06-14T14:56:22.644Z</updated>
    
    <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>Flutter版本更新记录</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-13</p></div></div><div class='timeline-item-content'><p><a href="https://flutter.cn/posts/whats-new-in-flutter-3">Flutter3 更新详解(支持macOS、Linux、曲面屏、游戏开发支持等)</a></p></div></div></div><h1 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h1><p><a href="https://book.flutterchina.club/chapter1/flutter_intro.html#_1-2-1-flutter-%E7%AE%80%E4%BB%8B">初识Flutter(Flutter框架结构)</a></p><h1 id="LocalKey、GlobalKey的作用和区别"><a href="#LocalKey、GlobalKey的作用和区别" class="headerlink" title="LocalKey、GlobalKey的作用和区别"></a>LocalKey、GlobalKey的作用和区别</h1><p>GlobalKey可以主动获取以及主动改变子控件的状态。</p><h1 id="Widget、Element、RenderObject三者之间的关系"><a href="#Widget、Element、RenderObject三者之间的关系" class="headerlink" title="Widget、Element、RenderObject三者之间的关系"></a>Widget、Element、RenderObject三者之间的关系</h1><p>Widget不是真正渲染UI的对象，它只是Element的一个配置描述，去告知Element应该如何去渲染，Widget和Element之间是一对多的关系。RenderObject才是实际渲染的对象，Element持有RenderObject和Widget。<br>大致总结三者的关系是：配置文件Widget生成了Element，而后创建RenderObject关联到Element的内部renderObject对象上，最后Flutter通过RenderObject数据来布局和绘制。</p><h1 id="Flutter和原生的通信方式"><a href="#Flutter和原生的通信方式" class="headerlink" title="Flutter和原生的通信方式"></a>Flutter和原生的通信方式</h1><p>1.BasicMessageChannel: 支持数据双向传递，有返回值，可用于传递字符串和半结构化的信息。<br>2.MethodChannel: 支持数据双向传递，有返回值，用于传递方法调用（method invocation）。<br>3.EventChannel: 仅支持数据单向传递，无返回值，用于数据流（event streams）的通信。</p><h1 id="StatefulWidget的生命周期"><a href="#StatefulWidget的生命周期" class="headerlink" title="StatefulWidget的生命周期"></a>StatefulWidget的生命周期</h1><h1 id="StatelessWidget和StatefulWidget的区别"><a href="#StatelessWidget和StatefulWidget的区别" class="headerlink" title="StatelessWidget和StatefulWidget的区别"></a>StatelessWidget和StatefulWidget的区别</h1><p>StatelessWidget: 不会发生状态改变的Widget，一旦创建就不关心任何变化，在下次构建之前都不会改变。它们除了依赖于自身的配置信息（在父节点构建时提供）外不再依赖于任何其他信息。<br>StatefulWidget: 在生命周期内，该类 Widget 所持有的数据可能会发生变化，这样的数据被称为 State，这些拥有动态内部数据的 Widget 被称为 StatefulWidget。<br>StatefulWidget 由两部分组成，在初始化时必须要在 createState()时初始化一个与之相关的 State 对象。</p><h1 id="setState刷新原理"><a href="#setState刷新原理" class="headerlink" title="setState刷新原理"></a>setState刷新原理</h1><p>调用一个Widget的setState()方法，它会将当前Widget及其所有子Widget都标记为重新刷新的状态，等待下一个Vsync刷新信号到来时重新刷新所有这些标记为刷新状态的控件，也就是调用他们的build方法。<br>局部刷新的话可以给子部件Widget添加一个GlobalKey，完成跟Element的绑定，拿到子部件Widget的State来进行刷新。</p><h1 id="Future中遍历数据量大的集合会造成卡顿吗"><a href="#Future中遍历数据量大的集合会造成卡顿吗" class="headerlink" title="Future中遍历数据量大的集合会造成卡顿吗"></a>Future中遍历数据量大的集合会造成卡顿吗</h1><p><br></p><div class="note icon flat"><i class="note-icon fab fa-internet-explorer"></i><p><a href="https://blog.csdn.net/u010960265/article/details/81361711">Flutter的两种编译模式</a><br><a href="https://zhuanlan.zhihu.com/p/439251771">Flutter实现动态化更新-技术预研</a><br><a href="https://www.jianshu.com/p/5fe4007a6070">Flutter面试题-基础篇</a><br><a href="https://www.jianshu.com/p/657732a2f333">https://www.jianshu.com/p/657732a2f333</a></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;timeline blue&quot;&gt;&lt;div class=&#39;timeline-item headline&#39;&gt;&lt;div class=&#39;timeline-item-title&#39;&gt;&lt;div class=&#39;item-circle&#39;&gt;&lt;p&gt;Flutter版本更新记录&lt;/p</summary>
      
    
    
    
    <category term="Flutter面试" scheme="https://zzming.cn/categories/Flutter%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="flutter" scheme="https://zzming.cn/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly主题</title>
    <link href="https://zzming.cn/post/2756f2af.html"/>
    <id>https://zzming.cn/post/2756f2af.html</id>
    <published>2022-05-28T21:28:28.000Z</published>
    <updated>2022-06-05T11:13:52.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h1><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly"><img src="https://github-readme-stats.vercel.app/api/pin/?username=jerryc127&repo=hexo-theme-butterfly&theme=vue&show_owner=true"/></a><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安裝文檔(一) 快速開始</a></li><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面</a></li><li><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">Butterfly 安裝文檔(四) 主題配置-2</a></li><li><a href="https://butterfly.js.org/posts/98d20436/">Butterfly 安裝文檔(五) 主題問答</a></li><li><a href="https://butterfly.js.org/posts/4073eda/">Butterfly 安裝文檔(六) 進階教程</a></li><li><a href="https://butterfly.js.org/posts/b37b5fe3/">自定義代碼配色</a></li><li><a href="https://butterfly.js.org/posts/507c070f/">Butterfly添加全局吸底Aplayer教程</a></li><li><a href="https://butterfly.js.org/posts/ea33ab97/">自定義側邊欄</a></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1987454">快速将Butterfly主题的CDN从jsDelivr切换至自建反向代理源</a></li><li><a href="https://blog.csdn.net/weixin_44318830/article/details/104884936">Hexo启动页面显示extends includes/layout.pug block content include includes</a></li><li><a href="https://blog.csdn.net/Galahadzhou/article/details/105355733">Hexo Permalink简化</a></li></ul><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><ul><li><a href="https://akilar.top/posts/615e2dec/#%E5%BC%95%E7%94%A8-note">Akilarの外挂标签引入</a></li><li><a href="https://tzy1997.com/articles/0xiipgum/">基于Butterfly的外挂标签引入</a></li><li><a href="https://tzy1997.com/articles/hexo541u/">Hexo+Butterfly主题美化</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Butterfly主题&quot;&gt;&lt;a href=&quot;#Butterfly主题&quot; class=&quot;headerlink&quot; title=&quot;Butterfly主题&quot;&gt;&lt;/a&gt;Butterfly主题&lt;/h1&gt;&lt;a class=&quot;ghcard&quot; rel=&quot;external nofol</summary>
      
    
    
    
    <category term="主题" scheme="https://zzming.cn/categories/%E4%B8%BB%E9%A2%98/"/>
    
    
    <category term="butterfly" scheme="https://zzming.cn/tags/butterfly/"/>
    
  </entry>
  
  <entry>
    <title>我们结婚了</title>
    <link href="https://zzming.cn/post/52aec6e1.html"/>
    <id>https://zzming.cn/post/52aec6e1.html</id>
    <published>2020-10-01T08:00:00.000Z</published>
    <updated>2022-06-01T16:10:45.526Z</updated>
    
    <content type="html"><![CDATA[<div class="video"><video controls preload><source src='https://img.upyun.zzming.cn/video/1609605466232679.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div>]]></content>
    
    
    <summary type="html">我们结婚了</summary>
    
    
    
    <category term="视频" scheme="https://zzming.cn/categories/%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android自定义可触摸滑动的转盘（仪表盘）</title>
    <link href="https://zzming.cn/post/20c6ad4c.html"/>
    <id>https://zzming.cn/post/20c6ad4c.html</id>
    <published>2017-01-06T22:20:17.000Z</published>
    <updated>2022-06-14T13:45:13.389Z</updated>
    
    <content type="html"><![CDATA[<p>快要过年了，在这里提前祝小伙伴们<strong>新年快乐</strong>！<br>新的一年，要多写点有质量的技术博客，哈哈。<br>上个月写了个自定义控件，也是我们项目的新需求，我就拿出来放在DEMO里，给大家参考一下，说实话这也是我自己正儿八经地写自定义控件。以前没写过，应该是没碰到需要自己来写的需求，网上都有现成的，这就是开源的一点好处吧，哈哈。<br>先放上效果图，<strong>可以用手指来触摸滑动的转盘（仪表盘）</strong>：</p><p><img src="https://fastly.jsdelivr.net/gh/zzmgoing/assets@main/img/1510656-20480c07bc0f10e8.gif" alt="滑动的仪表盘"></p><p>松手后自动指向最近数据：</p><p><img src="https://fastly.jsdelivr.net/gh/zzmgoing/assets@main/img/1510656-99f3628ed11bda88.gif" alt="松手后自动指向最近的指针"></p><p>首先，测量确定控件的宽高，在XML里面设置宽度就行了，高度在代码里会直接设置为宽度的一半，这里宽度我设置为<strong>match_parent</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//只需要设置宽度即可，高度默认为宽度的一半</span><br><span class="line"><span class="tag">&lt;<span class="name">com.zzm.zzmvp.ui.widget.FuelFillingView</span>    </span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span>    </span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>    </span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10px&quot;</span>    </span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10px&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测量设置宽高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> measureWidth(widthMeasureSpec);</span><br><span class="line">    setMeasuredDimension(width, width/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据xml的设定获取宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">measureWidth</span><span class="params">(<span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line">    <span class="comment">//wrap_content</span></span><br><span class="line">    <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//match_parent或者精确值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> specSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化各个变量，创建画笔等对象。<br>变量有圆弧的半径，半圆内长刻度的等分份数，一个长刻度内的等分份数，文字的数组，圆弧对应的矩阵等，最重要的就是手指旋转的角度，滑动的时候就是根据这个值来进行重绘。<br>我用了四个画笔，分别用来画默认的圆弧，选中的蓝色扇形，白色的扇形还有文字。<br>在<strong>onSizeChanged(int w, int h, int oldw, int oldh)</strong>方法中确定控件最终的宽高，得到圆弧的半径以及确定圆弧的矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> oldw, <span class="type">int</span> oldh)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    mViewWidth = w;</span><br><span class="line">    mViewHeight = h;</span><br><span class="line">    mRadius = mViewWidth / <span class="number">2</span> - dpToPx(<span class="number">10</span>);</span><br><span class="line">    mRadiusChoose = mViewWidth / <span class="number">2</span>;</span><br><span class="line">    mRadiusSmall = mRadius / <span class="number">2</span> - dpToPx(<span class="number">3</span>);</span><br><span class="line">    mRectFArc.set(-mRadius,-mRadius,mRadius,mRadius);</span><br><span class="line">    mRectFArcChoose.set(-mRadiusChoose,-mRadiusChoose,mRadiusChoose,mRadiusChoose);</span><br><span class="line">    mRectFArcSmall.set(-mRadiusSmall,-mRadiusSmall,mRadiusSmall,mRadiusSmall);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是绘制了，主要用到了画布的中心位移，旋转，坐标的转换，计算触摸点和中心点的角度，这个让我又把勾股定理研究了一下午，哈哈。</p><p>滑动事件就是将触摸的点转换为画布坐标，计算出角度后进行重绘。<br>代码较长，就贴上全部代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Path;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Rect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.RectF;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Typeface;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.TypedValue;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zzm.zzmlibrary.utils.LogUtils;</span><br><span class="line"><span class="keyword">import</span> com.zzm.zzmvp.R;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ZhongZiMing on 2016/12/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuelFillingView</span> <span class="keyword">extends</span> <span class="title class_">View</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">startAngle</span> <span class="operator">=</span> <span class="number">180</span>; <span class="comment">//圆弧起始角度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">sweepAngle</span> <span class="operator">=</span> <span class="number">180</span>; <span class="comment">//旋转的角度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mViewWidth,mViewHeight; <span class="comment">//控件的宽和高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mRadius; <span class="comment">//默认圆弧半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mStrokeWidth; <span class="comment">//默认圆弧宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mRadiusChoose;<span class="comment">//蓝色扇形半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mRadiusSmall;<span class="comment">//白色扇形半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> selectedColor; <span class="comment">//选中状态的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> unSelectedColor; <span class="comment">//未选中状态的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> backgroundColor; <span class="comment">//背景颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mSection</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 长刻度等分份数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mPortion</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 一个长刻度等分份数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mScaleLongLenth; <span class="comment">//长刻度相对圆心的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mScaleShortLenth; <span class="comment">//短刻度相对圆心的长度</span></span><br><span class="line">    <span class="keyword">private</span> String[] mTexts ; <span class="comment">//长刻度上的文字数组</span></span><br><span class="line">    <span class="keyword">private</span> String[] mTextsValue; <span class="comment">//跟刻度数字对应的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaintArc; <span class="comment">//默认圆弧</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaintArcChoose; <span class="comment">//选中的蓝色扇形</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaintArcSmall; <span class="comment">//内部白色扇形</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaintText; <span class="comment">//文字</span></span><br><span class="line">    <span class="keyword">private</span> Path mPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RectF mRectFArc;  <span class="comment">// 默认圆弧</span></span><br><span class="line">    <span class="keyword">private</span> RectF mRectFArcChoose;  <span class="comment">// 蓝色扇形</span></span><br><span class="line">    <span class="keyword">private</span> RectF mRectFArcSmall;  <span class="comment">//白色扇形</span></span><br><span class="line">    <span class="keyword">private</span> Rect mRectText; <span class="comment">//月份</span></span><br><span class="line">    <span class="keyword">private</span> RectF mRectFInnerArc; <span class="comment">//文字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bitmap mBitmapCar; <span class="comment">//小汽车</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap mBitmapPoint; <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">private</span> Matrix matrix ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> eventX ; <span class="comment">//手指按下的X坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> eventY ; <span class="comment">//手指按下的Y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mEvent</span> <span class="operator">=</span> MotionEvent.ACTION_UP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转的角度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">mSweepAngle</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FuelFillingView</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FuelFillingView</span><span class="params">(Context context, AttributeSet attrs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FuelFillingView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="built_in">this</span>.mContext =context;</span><br><span class="line"><span class="comment">//        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FuelFillView, defStyleAttr, 0);</span></span><br><span class="line">        <span class="comment">//添加attr属性</span></span><br><span class="line"><span class="comment">//        selectedColor = a.getColor(R.styleable.FuelFillView_arcColor, Color.parseColor(&quot;#52adff&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        a.recycle();</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onSizeChanged</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> oldw, <span class="type">int</span> oldh)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        mViewWidth = w;</span><br><span class="line">        mViewHeight = h;</span><br><span class="line">        mRadius = mViewWidth / <span class="number">2</span> - dpToPx(<span class="number">10</span>);</span><br><span class="line">        mRadiusChoose = mViewWidth / <span class="number">2</span>;</span><br><span class="line">        mRadiusSmall = mRadius / <span class="number">2</span> - dpToPx(<span class="number">3</span>);</span><br><span class="line">        mRectFArc.set(-mRadius,-mRadius,mRadius,mRadius);</span><br><span class="line">        mRectFArcChoose.set(-mRadiusChoose,-mRadiusChoose,mRadiusChoose,mRadiusChoose);</span><br><span class="line">        mRectFArcSmall.set(-mRadiusSmall,-mRadiusSmall,mRadiusSmall,mRadiusSmall);</span><br><span class="line">        mPaintText.setTextSize(spToPx(<span class="number">12</span>));</span><br><span class="line">        mPaintText.getTextBounds(<span class="string">&quot;0&quot;</span>, <span class="number">0</span>, <span class="string">&quot;0&quot;</span>.length(), mRectText);</span><br><span class="line">        mRectFInnerArc.set(-mRadius+mScaleLongLenth+mRectText.height()+dpToPx(<span class="number">6</span>),</span><br><span class="line">                -mRadius+mScaleLongLenth+mRectText.height()+dpToPx(<span class="number">6</span>),</span><br><span class="line">                mRadius-mScaleLongLenth-mRectText.height()-dpToPx(<span class="number">6</span>),</span><br><span class="line">                mRadius-mScaleLongLenth-mRectText.height()-dpToPx(<span class="number">6</span>));</span><br><span class="line">        mBitmapCar = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.icon_car);</span><br><span class="line">        <span class="type">Bitmap</span> <span class="variable">mBitmap</span> <span class="operator">=</span> BitmapFactory.decodeResource(mContext.getResources(), R.drawable.pointer_icon);</span><br><span class="line">        <span class="comment">//将指针进行缩放和旋转进行适配</span></span><br><span class="line">        matrix.postScale(<span class="number">1.0f</span>,((<span class="type">float</span>) (mRadiusChoose-mRadiusSmall))/(<span class="type">float</span>) mBitmap.getHeight());</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        mBitmapPoint = Bitmap.createBitmap(mBitmap, <span class="number">0</span>, <span class="number">0</span>, mBitmap.getWidth(), mBitmap.getHeight(), matrix, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(!mBitmap.isRecycled())&#123;</span><br><span class="line">            mBitmap.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> measureWidth(widthMeasureSpec);</span><br><span class="line">        setMeasuredDimension(width, width/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据xml的设定获取宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">measureWidth</span><span class="params">(<span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line">        <span class="comment">//wrap_content</span></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//match_parent或者精确值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> specSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">        mStrokeWidth = dpToPx(<span class="number">1</span>);</span><br><span class="line">        mScaleLongLenth = dpToPx(<span class="number">10</span>);</span><br><span class="line">        mScaleShortLenth = mScaleLongLenth / <span class="number">2</span>;</span><br><span class="line">        selectedColor = Color.parseColor(<span class="string">&quot;#52adff&quot;</span>);</span><br><span class="line">        unSelectedColor = Color.parseColor(<span class="string">&quot;#a1a5aa&quot;</span>);</span><br><span class="line">        backgroundColor = Color.parseColor(<span class="string">&quot;#ffffff&quot;</span>);</span><br><span class="line">        mTexts = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;及时充&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;3个月&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;6个月&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;12个月&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;24个月&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        mTextsValue = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;0折&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;9.8折&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;9.7折&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;9.6折&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;9.5折&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        mPaintArc = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        mPaintArc.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        mPaintArc.setColor(selectedColor);</span><br><span class="line">        mPaintArc.setStrokeWidth(mStrokeWidth);</span><br><span class="line">        mPaintArc.setStyle(Paint.Style.STROKE);</span><br><span class="line">        mPaintArc.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">        mPaintArcChoose = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        mPaintArcChoose.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        mPaintArcChoose.setColor(Color.parseColor(<span class="string">&quot;#3352adff&quot;</span>));</span><br><span class="line">        mPaintArcChoose.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">        mPaintArcSmall = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        mPaintArcSmall.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        mPaintArcSmall.setColor(backgroundColor);</span><br><span class="line">        mPaintArcSmall.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line"></span><br><span class="line">        mPaintText = <span class="keyword">new</span> <span class="title class_">Paint</span>();</span><br><span class="line">        mPaintText.setAntiAlias(<span class="literal">true</span>);</span><br><span class="line">        mPaintText.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">        mRectFArc = <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">        mRectFArcChoose = <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">        mRectFArcSmall = <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">        mRectText = <span class="keyword">new</span> <span class="title class_">Rect</span>();</span><br><span class="line">        mRectFInnerArc = <span class="keyword">new</span> <span class="title class_">RectF</span>();</span><br><span class="line">        mPath = <span class="keyword">new</span> <span class="title class_">Path</span>();</span><br><span class="line"></span><br><span class="line">        setBackgroundColor(backgroundColor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">        mEvent = event.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">//此处使用 getRawX，而不是 getX</span></span><br><span class="line">                eventX = event.getRawX();</span><br><span class="line">                eventY = event.getRawY();</span><br><span class="line">                invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//让指针指向最近的数据，不需要则可注释</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">surplus</span> <span class="operator">=</span> mSweepAngle % (sweepAngle / mSection);</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)((mSweepAngle - surplus) / (sweepAngle / mSection));</span><br><span class="line">                <span class="keyword">if</span>(TextUtils.isEmpty(mTexts[num])&amp;&amp;!TextUtils.isEmpty(mTexts[num+<span class="number">1</span>]))&#123;</span><br><span class="line">                    mSweepAngle = mSweepAngle + (sweepAngle / mSection) - surplus;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!TextUtils.isEmpty(mTexts[num]))&#123;</span><br><span class="line">                    mSweepAngle = mSweepAngle - surplus;</span><br><span class="line">                &#125;</span><br><span class="line">                invalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span>[] pts = &#123;eventX,eventY&#125;;</span><br><span class="line"></span><br><span class="line">        canvas.translate(mViewWidth/<span class="number">2</span>,mViewHeight);<span class="comment">//将画布中心移动到控件底部中间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mEvent==MotionEvent.ACTION_DOWN||mEvent==MotionEvent.ACTION_MOVE)&#123;</span><br><span class="line">            changeCanvasXY(canvas,pts);<span class="comment">//触摸点的坐标转换</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        drawArc(canvas);<span class="comment">//画选中的圆弧和未被选中的圆弧</span></span><br><span class="line"></span><br><span class="line">        drawLongLenth(canvas);<span class="comment">//画选中和未选中的长刻度</span></span><br><span class="line"></span><br><span class="line">        drawShortLenth(canvas);<span class="comment">//画选中和未选中的短刻度</span></span><br><span class="line"></span><br><span class="line">        drawText(canvas);<span class="comment">//画刻度上的文字</span></span><br><span class="line"></span><br><span class="line">        drawBlueArc(canvas);<span class="comment">//画选中的蓝色扇形</span></span><br><span class="line"></span><br><span class="line">        drawPoint(canvas); <span class="comment">//画指针</span></span><br><span class="line"></span><br><span class="line">        drawWhiteArc(canvas);<span class="comment">//画内部白色扇形</span></span><br><span class="line"></span><br><span class="line">        drawCar(canvas);<span class="comment">//画小汽车</span></span><br><span class="line"></span><br><span class="line">        drawValue(canvas); <span class="comment">//画折扣价</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeCanvasXY</span><span class="params">(Canvas canvas,<span class="type">float</span>[] pts)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前矩阵的逆矩阵</span></span><br><span class="line">        <span class="type">Matrix</span> <span class="variable">invertMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">        canvas.getMatrix().invert(invertMatrix);</span><br><span class="line">        <span class="comment">// 使用 mapPoints 将触摸位置转换为画布坐标</span></span><br><span class="line">        invertMatrix.mapPoints(pts);</span><br><span class="line">        <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(pts[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> Math.abs(pts[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> Math.sqrt(x*x+y*y);</span><br><span class="line">        <span class="type">float</span> <span class="variable">round</span> <span class="operator">=</span> (<span class="type">float</span>)(Math.asin(y/z)/Math.PI*<span class="number">180</span>);</span><br><span class="line">        LogUtils.e(<span class="string">&quot;触摸的点：X===&quot;</span>+pts[<span class="number">0</span>]+<span class="string">&quot;Y===&quot;</span>+pts[<span class="number">1</span>]+<span class="string">&quot;===当前角度：&quot;</span>+round);</span><br><span class="line">        <span class="keyword">if</span>(pts[<span class="number">0</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            mSweepAngle =  round;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mSweepAngle = sweepAngle - round;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawArc</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        mPaintArc.setColor(selectedColor);</span><br><span class="line">        canvas.drawArc(mRectFArc,startAngle,mSweepAngle,<span class="literal">false</span>,mPaintArc);</span><br><span class="line">        mPaintArc.setColor(unSelectedColor);</span><br><span class="line">        canvas.drawArc(mRectFArc,startAngle+mSweepAngle,sweepAngle-mSweepAngle,<span class="literal">false</span>,mPaintArc);</span><br><span class="line">        canvas.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawLongLenth</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">x0</span> <span class="operator">=</span> (<span class="type">float</span>) (- mRadius + mStrokeWidth);</span><br><span class="line">        <span class="type">float</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">float</span>) (- mRadius + mStrokeWidth + mScaleLongLenth);</span><br><span class="line">        mPaintArc.setStrokeWidth(mStrokeWidth*<span class="number">2</span>);</span><br><span class="line">        mPaintArc.setColor(selectedColor);</span><br><span class="line">        canvas.drawLine(x0, <span class="number">0</span>, x1, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        <span class="type">float</span> <span class="variable">angle</span> <span class="operator">=</span> sweepAngle * <span class="number">1f</span> / mSection;</span><br><span class="line">        mPaintArc.setStrokeWidth(mStrokeWidth);</span><br><span class="line">        <span class="type">float</span> <span class="variable">selectSection</span> <span class="operator">=</span> mSweepAngle / (sweepAngle / mSection);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= selectSection; i++) &#123;</span><br><span class="line">            canvas.rotate(angle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            canvas.drawLine(x0, <span class="number">0</span>, x1, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        &#125;</span><br><span class="line">        mPaintArc.setColor(unSelectedColor);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mSection - selectSection; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mSection - (<span class="type">int</span>)selectSection - <span class="number">1</span>)&#123;</span><br><span class="line">                mPaintArc.setStrokeWidth(mStrokeWidth*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.rotate(angle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            canvas.drawLine(x0, <span class="number">0</span>, x1, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawShortLenth</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        mPaintArc.setStrokeWidth(mStrokeWidth/<span class="number">2</span>);</span><br><span class="line">        mPaintArc.setColor(selectedColor);</span><br><span class="line">        <span class="type">float</span> <span class="variable">x0</span> <span class="operator">=</span> (<span class="type">float</span>) (- mRadius + mStrokeWidth);</span><br><span class="line">        <span class="type">float</span> <span class="variable">x2</span> <span class="operator">=</span> (<span class="type">float</span>) (- mRadius + mStrokeWidth + mScaleShortLenth);</span><br><span class="line">        canvas.drawLine(x0, <span class="number">0</span>, x2, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        <span class="type">float</span> <span class="variable">angle</span> <span class="operator">=</span> sweepAngle * <span class="number">1f</span> / (mSection*mPortion);</span><br><span class="line">        <span class="type">float</span> <span class="variable">mSelectSection</span> <span class="operator">=</span> mSweepAngle / (sweepAngle / (mSection*mPortion));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= mSelectSection ; i++) &#123;</span><br><span class="line">            canvas.rotate(angle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            canvas.drawLine(x0, <span class="number">0</span>, x2, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        &#125;</span><br><span class="line">        mPaintArc.setColor(unSelectedColor);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= (mSection * mPortion - mSelectSection); i++) &#123;</span><br><span class="line">            canvas.rotate(angle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            canvas.drawLine(x0, <span class="number">0</span>, x2, <span class="number">0</span>, mPaintArc);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawText</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        mPaintText.setTextSize(spToPx(<span class="number">12</span>));</span><br><span class="line">        mPaintText.setTextAlign(Paint.Align.LEFT);</span><br><span class="line">        mPaintText.setTypeface(Typeface.DEFAULT);</span><br><span class="line">        <span class="type">float</span> <span class="variable">mSectionSelect</span> <span class="operator">=</span> mSweepAngle / (sweepAngle / mSection);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mTexts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==(<span class="type">int</span>)mSectionSelect)&#123;</span><br><span class="line">                mPaintText.setColor(selectedColor);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mPaintText.setColor(unSelectedColor);</span><br><span class="line">            &#125;</span><br><span class="line">            mPaintText.getTextBounds(mTexts[i], <span class="number">0</span>, mTexts[i].length(), mRectText);</span><br><span class="line">            <span class="comment">// 粗略把文字的宽度视为圆心角2*θ对应的弧长，利用弧长公式得到θ，下面用于修正角度</span></span><br><span class="line">            <span class="type">float</span> θ = (<span class="type">float</span>) (<span class="number">180</span> * mRectText.width() / <span class="number">2</span> /</span><br><span class="line">                    (Math.PI * (mRadius - mScaleShortLenth - mRectText.height())));</span><br><span class="line">            mPath.reset();</span><br><span class="line">            mPath.addArc(</span><br><span class="line">                    mRectFInnerArc,</span><br><span class="line">                    startAngle + i * (sweepAngle / mSection) - θ, <span class="comment">// 正起始角度减去θ使文字居中对准长刻度</span></span><br><span class="line">                    sweepAngle</span><br><span class="line">            );</span><br><span class="line">            canvas.drawTextOnPath(mTexts[i], mPath, <span class="number">0</span>, <span class="number">0</span>, mPaintText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawBlueArc</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.drawArc(mRectFArcChoose,startAngle,mSweepAngle,<span class="literal">true</span>,mPaintArcChoose);</span><br><span class="line">        canvas.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawPoint</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.rotate(mSweepAngle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        canvas.drawBitmap(mBitmapPoint,-mRadiusChoose,-mBitmapPoint.getHeight()/<span class="number">2</span>,<span class="literal">null</span>);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawWhiteArc</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.drawArc(mRectFArcSmall,startAngle,sweepAngle,<span class="literal">true</span>,mPaintArcSmall);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawCar</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        canvas.drawBitmap(mBitmapCar,-mBitmapCar.getWidth()/<span class="number">2</span>,-mRadiusSmall/<span class="number">2</span>-mBitmapCar.getHeight(),<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">drawValue</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">        mPaintText.setTextSize(dpToPx(<span class="number">24</span>));</span><br><span class="line">        mPaintText.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">        mPaintText.setColor(Color.parseColor(<span class="string">&quot;#252c3d&quot;</span>));</span><br><span class="line">        mPaintText.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(mSweepAngle / (sweepAngle / mSection));</span><br><span class="line">        <span class="keyword">if</span>(!TextUtils.isEmpty(mTextsValue[num]))&#123;</span><br><span class="line">            canvas.drawText(mTextsValue[num],<span class="number">0</span>, -dpToPx(<span class="number">12</span>),mPaintText);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            canvas.drawText(mTextsValue[num+<span class="number">1</span>],<span class="number">0</span>, -dpToPx(<span class="number">12</span>),mPaintText);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dpToPx</span><span class="params">(<span class="type">int</span> dp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, getResources().getDisplayMetrics());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">spToPx</span><span class="params">(<span class="type">int</span> sp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, sp, getResources().getDisplayMetrics());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置长刻度上的文字数组和对应显示的值的数组，跟据数组个数来等分刻度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> texts</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTextsArray</span><span class="params">(String[] texts,String[] textsValue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(texts==<span class="literal">null</span>||texts.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.mTexts = texts;</span><br><span class="line">        <span class="built_in">this</span>.mTextsValue = textsValue;</span><br><span class="line">        <span class="built_in">this</span>.mSection = texts.length - <span class="number">1</span>;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码应该就看懂了，难点有一个，就是用到了逆矩阵，一开始我没想到这个方法，计算的角度总是不对，后来发现这个方法好使。使用event.getRawX()获取屏幕坐标，使用下面的方法转换为画布坐标后就轻松计算出了触摸点到中心点的角度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeCanvasXY</span><span class="params">(Canvas canvas,<span class="type">float</span>[] pts)</span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前矩阵的逆矩阵</span></span><br><span class="line">    <span class="type">Matrix</span> <span class="variable">invertMatrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    canvas.getMatrix().invert(invertMatrix);</span><br><span class="line">    <span class="comment">// 使用 mapPoints 将触摸位置转换为画布坐标</span></span><br><span class="line">    invertMatrix.mapPoints(pts);</span><br><span class="line">    <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(pts[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> Math.abs(pts[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> Math.sqrt(x*x+y*y);</span><br><span class="line">    <span class="type">float</span> <span class="variable">round</span> <span class="operator">=</span> (<span class="type">float</span>)(Math.asin(y/z)/Math.PI*<span class="number">180</span>);</span><br><span class="line">    LogUtils.e(<span class="string">&quot;触摸的点：X===&quot;</span>+pts[<span class="number">0</span>]+<span class="string">&quot;Y===&quot;</span>+pts[<span class="number">1</span>]+<span class="string">&quot;===当前角度：&quot;</span>+round);</span><br><span class="line">    <span class="keyword">if</span>(pts[<span class="number">0</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        mSweepAngle =  round;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        mSweepAngle = sweepAngle - round;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以根据自己的思路画成一个整圆，也可以自己给这个view添加attr属性进行设置，添加接口来获取选择的数据等，看大家的需要了。</p><blockquote><p>参考链接：<br><a href="http://www.gcssloop.com/customview/CustomViewIndex">http://www.gcssloop.com/customview/CustomViewIndex</a><br><a href="https://github.com/woxingxiao/DashboardView">https://github.com/woxingxiao/DashboardView</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快要过年了，在这里提前祝小伙伴们&lt;strong&gt;新年快乐&lt;/strong&gt;！&lt;br&gt;新的一年，要多写点有质量的技术博客，哈哈。&lt;br&gt;上个月写了个自定义控件，也是我们项目的新需求，我就拿出来放在DEMO里，给大家参考一下，说实话这也是我自己正儿八经地写自定义控件。以前没写过</summary>
      
    
    
    
    <category term="Android" scheme="https://zzming.cn/categories/Android/"/>
    
    
    <category term="自定义View" scheme="https://zzming.cn/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>旧时光的瓶子</title>
    <link href="https://zzming.cn/post/3a57339.html"/>
    <id>https://zzming.cn/post/3a57339.html</id>
    <published>2016-11-05T20:46:20.000Z</published>
    <updated>2022-06-06T04:57:28.974Z</updated>
    
    <content type="html"><![CDATA[<p>听听海边的风，沙子在我脚下流动<br>月亮从夜幕中浮起<br>潮水在暗涌<br>漂亮的贝壳已经被人拾去<br>我只能捧起这湿润的沙<br>装在旧时光的瓶子里</p><p>你的笑容总是浮现在我的梦<br>好像是前世的情<br>化作了今生的债<br>离开海边，沙子也会寂寞<br>不知道会过多久才明白<br>你所逃离的，正是你渴望的</p><p>远方的朋友<br>因为分离让我们彼此变得这般陌生<br>而今天的偶遇<br>是生命的轨迹，在岁月中重逢吗<br>你有了苍苍白发<br>而我已看不清</p><p>当潮水一次又一次<br>淹没了我的脚印<br>当手中的沙子反反复复<br>从指缝间逃走<br>我明白这旧时光的瓶子里<br>装的是自己</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;听听海边的风，沙子在我脚下流动&lt;br&gt;月亮从夜幕中浮起&lt;br&gt;潮水在暗涌&lt;br&gt;漂亮的贝壳已经被人拾去&lt;br&gt;我只能捧起这湿润的沙&lt;br&gt;装在旧时光的瓶子里&lt;/p&gt;
&lt;p&gt;你的笑容总是浮现在我的梦&lt;br&gt;好像是前世的情&lt;br&gt;化作了今生的债&lt;br&gt;离开海边，沙子也会寂寞&lt;b</summary>
      
    
    
    
    <category term="随笔" scheme="https://zzming.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
