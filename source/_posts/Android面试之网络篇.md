---
title: Android面试之网络篇
abbrlink: a3e07e13
date: 2022-06-04 22:40:51
tags: android
categories: Android面试
---

# TCP和UDP

> TCP（Transmission Control Protocol，传输控制协议）提供的是面向连接，可靠的字节流服务。
即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。

> UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的传输层协议。
UDP不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

TCP和UDP的相同点：都是**传输层**协议。

TCP和UDP的不同点：**报头不同、特点不同、协议不同**。

|不同点|TCP|UDP|
|--|--|--|
|报头不同|报头最大长度60个字节|UDP数据报最大长度64K（包含UDP首部），如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号|
|特点不同|{% span red, 面向连接： %}客户端和服务端的三次握手，四次挥手<br>{% span red, 可靠传输： %}序列号，确认应答机制，超时重传，拥塞控制<br>{% span red, 面向字节流： %}创建一个TCP的Socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；另一方面, TCP的一个连接, 既有发送缓冲区, 也有接收缓冲区, 那么对于这一个连接, 既可以读数据, 也可以写数据. 这个概念叫做全双工|{% span red, 无连接： %}知道对端的IP和端口号就能直接进行传输, 不需要建立连接<br>{% span red, 不可靠： %}没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息<br>{% span red, 面向数据报： %}不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并<br>{% span red, 数据接收不够灵活： %}但是能够明确区分两个数据包，避免粘包问题|
|协议不同|**HTTP**(超文本传输协议)、**HTTPS**(超文本传输安全协议)、**SSH**(安全外壳协议)、**Telnet**(电信网络协议)、**FTP**(文件传输协议)、**SMTP**(简单邮件传输协议)|**NFS**(网络文件系统)、**TFTP**(简单文件传输协议)、**DHCP**(动态主机配置协议)、**BOOTP**(启动协议, 用于无盘设备启动)、**DNS**(域名解析协议)|

## TCP/IP

TCP/IP一般指的是TCP/IP协议簇，主要包括了多个不同网络间实现信息传输涉及到的各种协议。主要包括以下几层：

- 应用层：主要提供数据和服务。比如HTTP，FTP，DNS等
- 传输层：负责数据的组装，分块。比如TCP，UDP等
- 网络层：负责告诉通信的目的地，比如IP等
- 数据链路层：负责连接网络的硬件部分，比如以太网，WIFI等

## TCP沾包问题

首先要明确，粘包问题中的*包*，是指的应用层的数据包。
- 在TCP的协议头中，没有如同UDP一样的*报文长度*这样的字段，但是有一个序号这样的字段；  
- 站在传输层的角度，TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；  
- 站在应用层的角度，看到的只是一串连续的字节数据，那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。  

解决方案：**明确两个包之间的边界。**
1. 对于定长的包，保证每次都按固定大小读取即可;  
2. 对于变长的包，可以在报头的位置, 约定一个包总长度的字段, 从而就知道了包的结束位置;  
3. 对于变长的包，还可以在包和包之间使用明确的分隔符；  
4. TLV格式的数据传输。

# HTTP和HTTPS

> Http：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

> Https：是以安全为目标的HTTP通道，简单讲是Http的安全版，即Http下加入SSL层，Https的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTP-TCP-IP

HTTPS-{% span red, SSL或TLS %}-TCP-IP

- SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。
- TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2、TLS 1.3  四个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。目前使用最广泛的是TLS 1.1、TLS 1.2、TLS 1.3。


## Http和Https的不同点

|区别|Http|Https|
|--|--|--|
|端口|80|443|
|证书|不需要|需要到CA申请证书，一般免费证书较少，因而需要一定费用|
|传输方式|明文传输|具有安全性的ssl加密传输|
|安全性|连接简单，无状态，安全性低|ssl+http构建的可进行加密传输、身份认证的网络协议，更加安全|


# HTTP1.0、1.1和2.0的区别

## HTTP1.1相对于1.0的优化

- {% span red, 缓存的处理： %}1.0根据header头的expires作为缓存依据，1.1引入了更多的缓存控制策略。（Entity tag、If-match）
- {% span red, 带宽的优化： %}1.0请求对象时服务器会返回整个对象，并且不支持断点续传，1.1在请求头加入了range头域，可以请求资源的某一部分，节省了带宽。
- {% span red, host处理： %}1.1中请求和响应都支持host头域，请求中没有的话会报错（400）。支持host头域是因为一个服务器可以部署多个虚拟主机。
- {% span red, 长链接优化： %}一个TCP连接可以传送多个HTTP请求和响应，减少了建立多个连接的消耗和延迟，默认打开了keep-alive，一定程度上弥补了1.0每次请求都要重新连接的缺陷。

## HTTP2.0相对于1.x的优化

- HTTP2请求{% span red, 报文头部采用二进制格式 %}传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。
- HTTP2的{% span red, 多路复用 %}解决了连接效率的问题，在一个TCP连接中可以存在多个流，通过帧中的标识知道属于哪个请求，可以避免HTTP旧版本中的线头阻塞问题，极大的提高了传输效率。

Http1.0每次请求都会建立一次TCP连接，也就是3次握手4次挥手，这个过程在一次请求中占用了比较长的时间；
Http1.1开启了Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题：串行文件传输消耗时间（单通道）、连接数过多服务器承载的最大并发数有限。

**多路复用：**
- 同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延时和内存消耗。
- 单个连接上可以并行交错的请求和响应，之间互不干扰。

# HTTPS原理和请求过程

> 因为HTTP有被窃听、被篡改、被冒充的风险，所以我们需要对HTTP请求进行加密，也就是在HTTP下面加入SSL层，进行证书的校验和数据的加密传输。

服务端需要在公认的证书颁发机构（CA）申请证书，证书一般包含了有效期、证书所有者、公钥、签名等信息；
当客户端发起HTTPS请求时，服务端需要将证书发送给客户端进行验证，验证通过后才能进行有效的数据传输。

- 客户端发起请求时会携带所支持的SSL版本，加密算法和Hash算法等信息；
- 服务端接收到请求后会选择加密算法与Hash算法，将自己的身份信息以证书的形式返回给客户端；
- 客户端首先会去验证证书的有效性（也就是证书颁发机构），查看是否可信任；
- 证书可信则根据本地根证书的{% span red, CA公钥 %}解密服务器证书获得内容和签名，验证签名、域名、有效期等；
- 如果验证通过，就使用服务器提供的公钥加密一串随机值发送给服务端；
- 服务端接收加密数据后使用私钥进行解密，得到随机值；
- 服务端将解密后的随机值作为私钥对数据进行加密（选择的加密算法）然后返回给客户端；
- 客户端用这个随机值（私钥）对服务端返回的数据进行解密，完成数据传输。

Https在传输证书和秘钥的过程中，使用的是非对称加密算法（保证绝对安全）；
完成验证后使用的是对称算法进行数据传输（保证传输效率）。

# 对称和非对称加密算法

|描述|对称加密|非对称加密|
|--|--|--|
|特点|秘钥相同、加解密算法不同|秘钥不同，加解密算法相同|
|算法|DES，AES算法|RSA，DSA算法|
|优点|传输效率高|安全，公钥即使被其他人获知，也无法解密数据|
|缺点|密钥有可能被破解，容易被伪造，传输过程中一旦密钥被其他人获知则可以进行数据解密|需要通信双方都有一套公钥和私钥|

## 数字签名
由于公钥是公开的，别人截获到公钥就能伪造数据进行传输，所以我们需要验证数据的来源。{% span blue, 在用公钥进行加密后，再用私钥进行一次加密，那么私钥的这次加密就叫做签名 %}。所以传输数据流程就变成了加密数据和签名数据，如果解出来都是同样的数据，那么则数据安全可靠。

## Base64算法
Base64是一种将二进制数据转换成64种字符组成的字符串的编码算法，主要用于非文本数据的传输，比如图片。可以将图片这种二进制数据转换成具体的字符串，进行保存和传输。

由于Base64算法是公开的，所以不能算加密算法。

# 网络耗时优化

1. DNS优化
使用HttpDns，即Http协议与自建的DNS服务器交互，获取响应IP，如果有问题的话再降级到运营商的LocalDNS解析。优点就是提升域名解析的速度。
2. 连接优化
HTTP2多路复用，同一个域名使用一个TCP链接就可以完成所有的请求。（HTTP1中并发多个请求需要建立多个TCP链接，HTTP2的多路复用技术代替了原来的序列和阻塞机制）
3. 域名合并
域名过多会使长链接复用效率低，每个域名都需要DNS解析，HTTP请求同时跟多个服务器保持长链接增加了客户端和服务端的资源消耗。
所以可以对不同域名进行合并，服务端再通过Header或者参数进行分发，这样可以提升长链接效率，减少DNS解析，减少客户端和服务端资源消耗。
4. TLS
升级服务器的TLS1.3版本，客户端在Android10和iOS12.2后默认支持TLS1.3，想要低版本支持需要接入三方扩展库。（TLS1.3版本对比1.2版本连接复用率高，提升了性能，废弃了一些相对不安全的算法，提升了安全性）
5. 数据压缩优化
ProtoBuffer是Google出的一种轻量并且高效的数据存储格式，性能比Json好，Size比Json小。

> [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231)
> [客户端网络优化(一)-原理篇](https://www.imgeek.org/article/825358030)